Create an Ecommerce dynamic price optimization and competitive analysis webapp with the following requirements, using real product data instead of dummy data:

1. **Tech Stack**:
   - Use a modern, free tech stack suitable for Replit’s environment.
   - Frontend: Choose a lightweight framework or library for a dynamic, responsive UI.
   - Backend: Select a simple server framework.
   - Database: Use an easy-to-use, file-based database.
   - Include tools for fetching real competitor data (e.g., HTTP requests and HTML parsing) or an API if available.
   - Add a free charting library for basic visualizations.

2. **Structure**:
   - Frontend:
     - Homepage: Display a list of real products with their current prices and competitor prices in a clean, visually appealing table.
     - Dashboard: Show a simple chart of price trends for one selected product (your price vs. competitors) based on real data.
     - Styling: Use a CSS framework or custom styles for a modern, responsive design (e.g., clean cards, grid layout, subtle effects).
   - Backend:
     - API endpoints:
       - GET `/api/products`: Return a list of real products with current prices from the database.
       - POST `/api/optimize-prices`: Calculate and update optimal prices based on competitor data (e.g., average competitor price adjusted by a small margin, like 5%).
       - GET `/api/competitor-data`: Fetch and return real competitor prices (via web scraping or a free API, if feasible in Replit).
     - Database:
       - Table for products: Store real product details (e.g., id, name, price, category).
       - Table for competitor prices: Store competitor data (e.g., product reference, competitor name, price, timestamp).
   - Logic: Fetch real competitor prices (e.g., from a public ecommerce site or free API) or simulate realistic data if scraping isn’t possible in Replit.

3. **Real Product Integration**:
   - Use real product data by:
     - Option 1: Fetching a small dataset from a free, public ecommerce API (e.g., a marketplace like eBay or a product data API) and storing it in the database.
     - Option 2: Scraping a public ecommerce site (e.g., a retailer’s product listing page) for 5-10 real products (e.g., "Nike Shoes", "Sony Headphones") and their prices, if Replit allows.
     - Option 3: Preload the database with a small, manually curated list of real products and prices (e.g., sourced from Amazon, Walmart) as a fallback, then simulate competitor price updates.
   - Competitor Data: Fetch or simulate prices from 2-3 real competitors (e.g., Amazon, Walmart, Target) for these products.

4. **Features**:
   - Display 5-10 real products (e.g., "Apple AirPods", "Samsung Galaxy Watch") with their current prices.
   - Show real-time or simulated competitor prices for each product from 2-3 sources.
   - Include a button to "Optimize Prices" that updates your prices based on competitor data (e.g., set your price slightly below the average competitor price while maintaining a margin).
   - Dashboard with a basic price trend chart for one product, using real or realistically simulated data over a short timeframe (e.g., last 7 days).

5. **Setup**:
   - Use Replit’s default environment (e.g., Node.js, Python, etc., as you see fit).
   - Organize code in clear folders (e.g., separate frontend and backend).
   - Include a `package.json` or equivalent with all necessary dependencies (all free).
   - Provide a README with instructions to run the app (e.g., install dependencies and start commands).

6. **Notes**:
   - Keep it simple, lightweight, and functional, avoiding complex features.
   - Focus on a clean, professional UI that looks good on desktop and mobile.
   - If real-time scraping or API access isn’t feasible in Replit, simulate realistic competitor price updates (e.g., fluctuate prices daily within a range like $10-$100 based on real-world examples).
   - Ensure all data sources or methods comply with Replit’s capabilities and terms (e.g., no paid APIs).

Generate the full app code, including file structure, and ensure it runs on Replit with no paid dependencies. Prioritize using real product data over dummy data wherever possible.